use core::{
        hash::Hash,
        ops::{Range, RangeFrom},
};

use crate::{error::Located, parser::*, stream::Stream};

use self::private::Sealed;

mod private {
        pub trait Sealed {}
}

pub trait InputType: Sealed {
        #[doc(hidden)]
        type Offset: Copy + Hash + Ord + Into<usize>;
        type Token;

        #[doc(hidden)]
        fn start(&self) -> Self::Offset;

        #[doc(hidden)]
        unsafe fn next(&self, offset: Self::Offset) -> (Self::Offset, Option<Self::Token>);

        #[doc(hidden)]
        fn prev(offset: Self::Offset) -> Self::Offset;
}

impl<'a> Sealed for &'a str {}
impl<'a> InputType for &'a str {
        type Token = char;
        type Offset = usize;

        #[inline]
        fn start(&self) -> Self::Offset {
                0
        }

        fn prev(offset: Self::Offset) -> Self::Offset {
                offset.saturating_sub(1)
        }

        #[inline(always)]
        unsafe fn next(&self, offset: Self::Offset) -> (Self::Offset, Option<Self::Token>) {
                if offset < self.len() {
                        // SAFETY: `offset < self.len()` above guarantees offset is in-bounds
                        //         We only ever return offsets that are at a character boundary
                        let c = unsafe {
                                self.get_unchecked(offset..)
                                        .chars()
                                        .next()
                                        .unwrap_unchecked()
                        };
                        (offset + c.len_utf8(), Some(c))
                } else {
                        (offset, None)
                }
        }
}

impl<'a, T> Sealed for &'a [T] {}
impl<'a, T: Clone> InputType for &'a [T] {
        type Offset = usize;
        type Token = T;

        unsafe fn next(&self, offset: Self::Offset) -> (Self::Offset, Option<Self::Token>) {
                if offset < self.len() {
                        // SAFETY: `offset < self.len()` above guarantees offset is in-bounds
                        //         We only ever return offsets that are at a character boundary
                        let tok = unsafe { self.get_unchecked(offset) };
                        (offset + 1, Some(tok.clone()))
                } else {
                        (offset, None)
                }
        }

        fn start(&self) -> Self::Offset {
                0
        }

        fn prev(offset: Self::Offset) -> Self::Offset {
                offset.saturating_sub(1)
        }
}

impl<I: Iterator> Sealed for Stream<I> {}

#[doc(hidden)]
pub trait ExactSizeInput: InputType {
        unsafe fn span_from(&self, range: RangeFrom<Self::Offset>) -> Range<usize>;
}

pub(crate) struct Errors<T, E> {
        pub(crate) alt: Option<Located<T, E>>,
        pub(crate) secondary: Vec<Located<T, E>>,
}

pub struct Input<I: InputType, E: ParserExtras<I>> {
        pub(crate) offset: I::Offset,
        pub(crate) input: I,
        pub(crate) cx: E::Context,
        pub(crate) errors: Errors<I::Offset, E::Error>,
}

impl<I: InputType, E: ParserExtras<I>> Input<I, E> {
        #[inline]
        pub(crate) fn skip_while(&mut self, mut f: impl FnMut(&I::Token) -> bool) {
                loop {
                        // SAFETY: offset was generated by previous call to `Input::next`
                        let (offset, token) = unsafe { self.input.next(self.offset) };
                        if token.filter(&mut f).is_none() {
                                break;
                        }
                        self.offset = offset;
                }
        }
        #[inline(always)]
        pub(crate) fn next_inner(&mut self) -> (I::Offset, Option<I::Token>) {
                // SAFETY: offset was generated by previous call to `Input::next`
                let (offset, token) = unsafe { self.input.next(self.offset) };
                self.offset = offset;
                (self.offset, token)
        }
}
